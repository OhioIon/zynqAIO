#define DSHOTWAVEFORM_C

/** \file  dshotWaveform.c
 *  \brief dshotWaveform device driver
 *
 *  \author OhioIon 2019
 *
 */

/****************** Includes ********************/

#include "dshotWaveform.h"

/******************* Defines ********************/

#define REG0_D   0x0 // Register 0 - Total bit-time count and enable flag
#define REG1_D   0x4 // Register 1 - High bit-time and low bit-time count
#define REG2_D   0x8 // Register 2 - Clock frequency connected to IP core in Hz

#define REG0_ENABLE 0x80000000 // Register 0 - Waveform enable flag

/******************** Types *********************/

/***************** Private Data *****************/

/****************** Prototypes ******************/

static inline void WrReg32(volatile uint32_t *p, volatile uint32_t d){*p = d;} // Write 32-bit word to register space
static inline volatile uint32_t RdReg32(volatile uint32_t *p){return *p;}      // Read 32-bit word from register space

/**************** Implementation ****************/


/** \brief Initialize and enable DShot waveform generation instance
 *
 * The waveform generated by this module is a cyclic repetition of the
 * 0-bit and 1-bit pattern of the DShot protocol. This is used by the
 * DShot peripheral.
 *
 * \param  ps: Driver instance pointer
 * \return 0 ok, 1 error
 *
 */
bool dshotWaveform_init( dshotWaveform_ts *ps )
{
  // Pointer check
  if( ps == NULL ) return 1;

  // Parameter Check
  if( ps->prm_s.addrBas_pv == NULL ) return 1;
  if( (ps->prm_s.speed_kbps_u16 < 150U) || (ps->prm_s.speed_kbps_u16 > 2400U) ) return 1;

  // Read AXI4-lite clock frequency from reg2
  uint32_t frqClk_Hz_u32 = RdReg32( ps->prm_s.addrBas_pv + REG2_D );
  if( frqClk_Hz_u32 == 0U ) return 1;

  // Calculate total bit-time (round)
  uint32_t cntTot_u32 = (frqClk_Hz_u32 + (uint32_t)ps->prm_s.speed_kbps_u16 * 500U) / ((uint32_t)ps->prm_s.speed_kbps_u16 * 1000U);

  // Calculate high-time for bit pattern 1 (round)
  uint32_t cntT1H_u32 = (uint32_t)(0.748503f * cntTot_u32);

  // Calculate high-time for bit pattern 0 (floor)
  uint32_t cntT0H_u32 = cntT1H_u32 / 2;

  // Make some final checks after rounding
  if( cntT0H_u32 >= cntT1H_u32 ) return 1;
  if( cntT1H_u32 >= cntTot_u32 ) return 1;
  if( cntTot_u32 >= 0xFFFF     ) return 1;

  // Write high/low counts to reg1
  WrReg32( ps->prm_s.addrBas_pv + REG1_D, (cntT1H_u32 << 16) | cntT0H_u32 );

  // Write total count to reg0 and enable continuous waveform generation
  WrReg32( ps->prm_s.addrBas_pv + REG0_D, (cntTot_u32 - 1) | REG0_ENABLE );

  return 0; // OK
}

// EOF
